## 链表和邻接表

C++中的指针链表在机试中很少使用，因为每次都要建立新对象很耗时（大概率会超时）。
本节讲述用数组模拟链表。

1. 单链表
   用的的最多的是邻接表（N个链表），用于存储图和树。
2. 双链表
   专用于优化某一些问题。

**使用数组实现单链表：**

- e[N],ne[N]分别表示值和下一节点指针，可见使用下表关联的。

* **实现要点**：
  
  * 使用两个整型数组分别存储值和指针
  * 通过数组下标建立节点间联系
  * 空指针统一用-1表示

**使用数组实现双链表：**

- l[N],r[N]分别表示左右相邻节点下标,e[N]表示value。

实现邻接表：

- 实际上用单链表数组完成
- 留待第三章图论来讲

## 栈和队列

### 单调栈问题

给定序列，找到每个数左侧最近的较小/较大数。

例如：

| 3  | 4 | 2  | 7 | 5 |
| -- | - | -- | - | - |
| -1 | 3 | -1 | 2 | 2 |

暴力做法：两重循环找到每个数左侧较小数，时间复杂度显然是O(N^2)

单调栈做法：逐次弹出栈顶知道栈顶不大于当前元素，保证每次遍历时都是单调递增的。 由于栈中每个元素最多进出各一次，因此时间复杂度为O(N)

### 单调队列问题

滑动窗口里的最值。

### KMP算法

1. 暴力算法怎么做
2. 如何优化

###### **暴力匹配算法**

* **基本思路**：先理解暴力匹配的做法，这是KMP算法的基础
* **实现方式**：
  
  * 使用双重循环：外层循环遍历主串s（长串），内层循环遍历模式串p（短串）
  * 从主串每个位置开始尝试完整匹配模式串
  * 设置flag标记匹配状态，遇到不匹配时break并移动一位重新开始
* **时间复杂度**：﻿O(n×m)O(n \\times m)**O**(**n**×**m**)﻿
  
  ，其中n是主串长度，m是模式串长度

###### **KMP算法**

**核心观察**： 暴力算法每次之移动一位，忽略了一匹配的部分信息。
**关键改进**：匹配失败是，利用已经匹配部分的信息计算最大可移动预处理模式串，得到每个位置的最长公共前后缀长度（next数组）。
**移动原理**：

- 已匹配部分的前缀和后缀相同时，可以直接将模式串移动到后缀位置
- 这样避免了重复比较已知匹配的部分

### tire树

高效的存储和查找字符串集合的树形数据结构。

- 处理字符串通常只包含小写/大写字母、数字等的有限字符集
- 具有共享前缀的字符集会共享存储路径
- 在单词结尾节点需要特殊标记（如星号或布尔值）

*存储原理*：

- 从根节点/空节点开始创建
- 按字符顺序逐层扩展子节点
- 每个节点对应一个字符
- 子节点指针数量等于字符集大小
- 必须标记单词结束节点（因为单词结点可能会被复用为路径，也可以防止子字符串被误判为字符串）

### 并查集

代码简单、思路精巧

每个集合用一棵树表示，树根编号即集合编号

用于将两个集合合并或判断两个元素是否再一个集合当中

*存储方式*：每个节点存储父节点，p[x]表示x的父节点

*核心操作*:

- 判断树根:当p[x]==x时,x为树根
- 求集合编号:通过while循环找到根节点
- 合并集合:设p[x]为x的跟p[y]为y的根,执行p[p[x]]=p[y]

